//
// Generated by Bluespec Compiler, version 2016.07.beta1 (build 34806, 2016-07-05)
//
// On Sat May  5 02:07:53 UTC 2018
//
//
// Ports:
// Name                         I/O  size props
// RDY_setValue                   O     1 const
// RDY_increment                  O     1 const
// readVal                        O    10 reg
// RDY_readVal                    O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// setValue_val                   I    10
// increment_inc                  I    10
// EN_setValue                    I     1
// EN_increment                   I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkCounterTest(CLK,
		     RST_N,

		     setValue_val,
		     EN_setValue,
		     RDY_setValue,

		     increment_inc,
		     EN_increment,
		     RDY_increment,

		     readVal,
		     RDY_readVal);
  input  CLK;
  input  RST_N;

  // action method setValue
  input  [9 : 0] setValue_val;
  input  EN_setValue;
  output RDY_setValue;

  // action method increment
  input  [9 : 0] increment_inc;
  input  EN_increment;
  output RDY_increment;

  // value method readVal
  output [9 : 0] readVal;
  output RDY_readVal;

  // signals for module outputs
  wire [9 : 0] readVal;
  wire RDY_increment, RDY_readVal, RDY_setValue;

  // register counter
  reg [9 : 0] counter;
  wire [9 : 0] counter$D_IN;
  wire counter$EN;

  // inputs to muxes for submodule ports
  wire [9 : 0] MUX_counter$write_1__VAL_2;

  // action method setValue
  assign RDY_setValue = 1'd1 ;

  // action method increment
  assign RDY_increment = 1'd1 ;

  // value method readVal
  assign readVal = counter ;
  assign RDY_readVal = 1'd1 ;

  // inputs to muxes for submodule ports
  assign MUX_counter$write_1__VAL_2 = counter + increment_inc ;

  // register counter
  assign counter$D_IN =
	     EN_setValue ? setValue_val : MUX_counter$write_1__VAL_2 ;
  assign counter$EN = EN_setValue || EN_increment ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        counter <= `BSV_ASSIGNMENT_DELAY 10'd0;
      end
    else
      begin
        if (counter$EN) counter <= `BSV_ASSIGNMENT_DELAY counter$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    counter = 10'h2AA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkCounterTest

