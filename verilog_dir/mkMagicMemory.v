//
// Generated by Bluespec Compiler, version 2016.07.beta1 (build 34806, 2016-07-05)
//
// On Tue Oct 30 18:01:59 UTC 2018
//
//
// Ports:
// Name                         I/O  size props
// put                            O    34
// RDY_put                        O     1
// get0                           O    34
// RDY_get0                       O     1
// get1                           O    34
// RDY_get1                       O     1
// get2                           O    34
// RDY_get2                       O     1
// get3                           O    34
// RDY_get3                       O     1
// RDY_nodeDump                   O     1
// dumpCompletion                 O     1
// RDY_dumpCompletion             O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// put_memReq                     I    55
// get0_addr                      I    14
// get1_addr                      I    14
// get2_addr                      I    14
// get3_addr                      I    14
// EN_nodeDump                    I     1
// EN_put                         I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkMagicMemory(CLK,
		     RST_N,

		     put_memReq,
		     EN_put,
		     put,
		     RDY_put,

		     get0_addr,
		     get0,
		     RDY_get0,

		     get1_addr,
		     get1,
		     RDY_get1,

		     get2_addr,
		     get2,
		     RDY_get2,

		     get3_addr,
		     get3,
		     RDY_get3,

		     EN_nodeDump,
		     RDY_nodeDump,

		     dumpCompletion,
		     RDY_dumpCompletion);
  input  CLK;
  input  RST_N;

  // actionvalue method put
  input  [54 : 0] put_memReq;
  input  EN_put;
  output [33 : 0] put;
  output RDY_put;

  // value method get0
  input  [13 : 0] get0_addr;
  output [33 : 0] get0;
  output RDY_get0;

  // value method get1
  input  [13 : 0] get1_addr;
  output [33 : 0] get1;
  output RDY_get1;

  // value method get2
  input  [13 : 0] get2_addr;
  output [33 : 0] get2;
  output RDY_get2;

  // value method get3
  input  [13 : 0] get3_addr;
  output [33 : 0] get3;
  output RDY_get3;

  // action method nodeDump
  input  EN_nodeDump;
  output RDY_nodeDump;

  // value method dumpCompletion
  output dumpCompletion;
  output RDY_dumpCompletion;

  // signals for module outputs
  wire [33 : 0] get0, get1, get2, get3, put;
  wire RDY_dumpCompletion,
       RDY_get0,
       RDY_get1,
       RDY_get2,
       RDY_get3,
       RDY_nodeDump,
       RDY_put,
       dumpCompletion;

  // register dumpState
  reg dumpState;
  wire dumpState$D_IN, dumpState$EN;

  // register mem_counter
  reg [13 : 0] mem_counter;
  wire [13 : 0] mem_counter$D_IN;
  wire mem_counter$EN;

  // register mem_state
  reg [2 : 0] mem_state;
  wire [2 : 0] mem_state$D_IN;
  wire mem_state$EN;

  // register sizeCounter
  reg [13 : 0] sizeCounter;
  wire [13 : 0] sizeCounter$D_IN;
  wire sizeCounter$EN;

  // ports of submodule mem
  reg [13 : 0] mem$ADDR_1;
  wire [33 : 0] mem$D_IN,
		mem$D_OUT_1,
		mem$D_OUT_2,
		mem$D_OUT_3,
		mem$D_OUT_4,
		mem$D_OUT_5;
  wire [13 : 0] mem$ADDR_2, mem$ADDR_3, mem$ADDR_4, mem$ADDR_5, mem$ADDR_IN;
  wire mem$WE;

  // inputs to muxes for submodule ports
  wire MUX_mem_state$write_1__SEL_2, MUX_mem_state$write_1__SEL_3;

  // remaining internal signals
  wire fileAppend_C_mem_sub_mem_counter_0_1_BITS_33_T_ETC___d19,
       fileCreate_C____d67,
       mem_counter_0_EQ_sizeCounter___d21;

  // actionvalue method put
  assign put = mem$D_OUT_1 ;
  assign RDY_put = mem_state == 3'd1 ;

  // value method get0
  assign get0 = mem$D_OUT_5 ;
  assign RDY_get0 = mem_state == 3'd1 ;

  // value method get1
  assign get1 = mem$D_OUT_4 ;
  assign RDY_get1 = mem_state == 3'd1 ;

  // value method get2
  assign get2 = mem$D_OUT_3 ;
  assign RDY_get2 = mem_state == 3'd1 ;

  // value method get3
  assign get3 = mem$D_OUT_2 ;
  assign RDY_get3 = mem_state == 3'd1 ;

  // action method nodeDump
  assign RDY_nodeDump = mem_state == 3'd1 ;

  // value method dumpCompletion
  assign dumpCompletion = !dumpState ;
  assign RDY_dumpCompletion = 1'd1 ;

  // submodule mem
  RegFileLoad #(.file("mem.vmh"),
		.addr_width(32'd14),
		.data_width(32'd34),
		.lo(14'h0),
		.hi(14'd16383),
		.binary(1'd0)) mem(.CLK(CLK),
				   .ADDR_1(mem$ADDR_1),
				   .ADDR_2(mem$ADDR_2),
				   .ADDR_3(mem$ADDR_3),
				   .ADDR_4(mem$ADDR_4),
				   .ADDR_5(mem$ADDR_5),
				   .ADDR_IN(mem$ADDR_IN),
				   .D_IN(mem$D_IN),
				   .WE(mem$WE),
				   .D_OUT_1(mem$D_OUT_1),
				   .D_OUT_2(mem$D_OUT_2),
				   .D_OUT_3(mem$D_OUT_3),
				   .D_OUT_4(mem$D_OUT_4),
				   .D_OUT_5(mem$D_OUT_5));

  // inputs to muxes for submodule ports
  assign MUX_mem_state$write_1__SEL_2 =
	     mem_state == 3'd0 && mem_counter_0_EQ_sizeCounter___d21 ;
  assign MUX_mem_state$write_1__SEL_3 = EN_nodeDump && fileCreate_C____d67 ;

  // register dumpState
  assign dumpState$D_IN = 1'd0 ;
  assign dumpState$EN = MUX_mem_state$write_1__SEL_2 ;

  // register mem_counter
  assign mem_counter$D_IN = mem_counter + 14'd1 ;
  assign mem_counter$EN = mem_state == 3'd0 ;

  // register mem_state
  assign mem_state$D_IN = MUX_mem_state$write_1__SEL_3 ? 3'd0 : 3'd1 ;
  assign mem_state$EN =
	     mem_state == 3'd2 && mem$D_OUT_1[4:0] == 5'd28 ||
	     mem_state == 3'd0 && mem_counter_0_EQ_sizeCounter___d21 ||
	     EN_nodeDump && fileCreate_C____d67 ;

  // register sizeCounter
  assign sizeCounter$D_IN = sizeCounter + 14'd1 ;
  assign sizeCounter$EN = mem_state == 3'd2 && mem$D_OUT_1[4:0] != 5'd28 ;

  // submodule mem
  always@(mem_state or sizeCounter or mem_counter or EN_put or put_memReq)
  begin
    case (1'b1) // synopsys parallel_case
      mem_state == 3'd2: mem$ADDR_1 = sizeCounter;
      mem_state == 3'd0: mem$ADDR_1 = mem_counter;
      EN_put: mem$ADDR_1 = put_memReq[47:34];
      default: mem$ADDR_1 = 14'b10101010101010 /* unspecified value */ ;
    endcase
  end
  assign mem$ADDR_2 = get3_addr ;
  assign mem$ADDR_3 = get2_addr ;
  assign mem$ADDR_4 = get1_addr ;
  assign mem$ADDR_5 = get0_addr ;
  assign mem$ADDR_IN = put_memReq[47:34] ;
  assign mem$D_IN = { put_memReq[18:5], put_memReq[33:19], put_memReq[4:0] } ;
  assign mem$WE = EN_put ;

  // remaining internal signals
  assign fileAppend_C_mem_sub_mem_counter_0_1_BITS_33_T_ETC___d19 =
	     $imported_fileAppend_C(mem$D_OUT_1) ;
  assign fileCreate_C____d67 = $imported_fileCreate_C ;
  assign mem_counter_0_EQ_sizeCounter___d21 = mem_counter == sizeCounter ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        dumpState <= `BSV_ASSIGNMENT_DELAY 1'd1;
	mem_counter <= `BSV_ASSIGNMENT_DELAY 14'd0;
	mem_state <= `BSV_ASSIGNMENT_DELAY 3'd2;
	sizeCounter <= `BSV_ASSIGNMENT_DELAY 14'd0;
      end
    else
      begin
        if (dumpState$EN) dumpState <= `BSV_ASSIGNMENT_DELAY dumpState$D_IN;
	if (mem_counter$EN)
	  mem_counter <= `BSV_ASSIGNMENT_DELAY mem_counter$D_IN;
	if (mem_state$EN) mem_state <= `BSV_ASSIGNMENT_DELAY mem_state$D_IN;
	if (sizeCounter$EN)
	  sizeCounter <= `BSV_ASSIGNMENT_DELAY sizeCounter$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    dumpState = 1'h0;
    mem_counter = 14'h2AAA;
    mem_state = 3'h2;
    sizeCounter = 14'h2AAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (mem_state == 3'd0 &&
	  !fileAppend_C_mem_sub_mem_counter_0_1_BITS_33_T_ETC___d19)
	$display("Data failed to load!");
    if (RST_N != `BSV_RESET_VALUE)
      if (mem_state == 3'd0 && mem_counter_0_EQ_sizeCounter___d21)
	$display("Memory Dump Complete!");
  end
  // synopsys translate_on
endmodule  // mkMagicMemory

